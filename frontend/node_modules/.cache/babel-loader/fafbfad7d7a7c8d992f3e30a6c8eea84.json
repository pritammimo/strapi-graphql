{"ast":null,"code":"import { canUseAsyncIteratorSymbol } from \"../../../utilities/index.js\";\nexport default function nodeStreamIterator(stream) {\n  var cleanup = null;\n  var error = null;\n  var done = false;\n  var data = [];\n  var waiting = [];\n\n  function onData(chunk) {\n    if (error) return;\n\n    if (waiting.length) {\n      var shiftedArr = waiting.shift();\n\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({\n          value: chunk,\n          done: false\n        });\n      }\n    }\n\n    data.push(chunk);\n  }\n\n  function onError(err) {\n    error = err;\n    var all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n\n  function onEnd() {\n    done = true;\n    var all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({\n        value: undefined,\n        done: true\n      });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext() {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length) return resolve({\n        value: data.shift(),\n        done: false\n      });\n      if (done) return resolve({\n        value: undefined,\n        done: true\n      });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  var iterator = {\n    next: function () {\n      return getNext();\n    }\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function () {\n      return this;\n    };\n  }\n\n  return iterator;\n}","map":{"version":3,"sources":["../../../../src/link/http/iterators/nodeStream.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Original source:\n * https://github.com/kmalakoff/response-iterator/blob/master/src/iterators/nodeStream.ts\n */\n\nimport { Readable as NodeReadableStream } from \"stream\";\nimport { canUseAsyncIteratorSymbol } from \"../../../utilities\";\n\ninterface NodeStreamIterator<T> {\n  next(): Promise<IteratorResult<T, boolean | undefined>>;\n  [Symbol.asyncIterator]?(): AsyncIterator<T>;\n}\n\nexport default function nodeStreamIterator<T>(\n  stream: NodeReadableStream\n): AsyncIterableIterator<T> {\n  let cleanup: (() => void) | null = null;\n  let error: Error | null = null;\n  let done = false;\n  const data: unknown[] = [];\n\n  const waiting: [\n    (\n      value:\n        | IteratorResult<T, boolean | undefined>\n        | PromiseLike<IteratorResult<T, boolean | undefined>>\n    ) => void,\n    (reason?: any) => void\n  ][] = [];\n\n  function onData(chunk: any) {\n    if (error) return;\n    if (waiting.length) {\n      const shiftedArr = waiting.shift();\n      if (Array.isArray(shiftedArr) && shiftedArr[0]) {\n        return shiftedArr[0]({ value: chunk, done: false });\n      }\n    }\n    data.push(chunk);\n  }\n  function onError(err: Error) {\n    error = err;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[1](err);\n    });\n    !cleanup || cleanup();\n  }\n  function onEnd() {\n    done = true;\n    const all = waiting.slice();\n    all.forEach(function (pair) {\n      pair[0]({ value: undefined, done: true });\n    });\n    !cleanup || cleanup();\n  }\n\n  cleanup = function () {\n    cleanup = null;\n    stream.removeListener(\"data\", onData);\n    stream.removeListener(\"error\", onError);\n    stream.removeListener(\"end\", onEnd);\n    stream.removeListener(\"finish\", onEnd);\n    stream.removeListener(\"close\", onEnd);\n  };\n  stream.on(\"data\", onData);\n  stream.on(\"error\", onError);\n  stream.on(\"end\", onEnd);\n  stream.on(\"finish\", onEnd);\n  stream.on(\"close\", onEnd);\n\n  function getNext(): Promise<IteratorResult<T, boolean | undefined>> {\n    return new Promise(function (resolve, reject) {\n      if (error) return reject(error);\n      if (data.length) return resolve({ value: data.shift() as T, done: false });\n      if (done) return resolve({ value: undefined, done: true });\n      waiting.push([resolve, reject]);\n    });\n  }\n\n  const iterator: NodeStreamIterator<T> = {\n    next(): Promise<IteratorResult<T, boolean | undefined>> {\n      return getNext();\n    },\n  };\n\n  if (canUseAsyncIteratorSymbol) {\n    iterator[Symbol.asyncIterator] = function (): AsyncIterator<T> {\n      return this;\n    };\n  }\n\n  return iterator as AsyncIterableIterator<T>;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}