{"ast":null,"code":"import { __assign, __awaiter, __generator } from \"tslib\";\nimport { responseIterator } from \"./responseIterator.js\";\nimport { throwServerError } from \"../utils/index.js\";\nimport { PROTOCOL_ERRORS_SYMBOL } from \"../../errors/index.js\";\nimport { isApolloPayloadResult } from \"../../utilities/common/incrementalResult.js\";\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nexport function readMultipartBody(response, observer) {\n  var _a, _b, _c, _d, _e;\n\n  return __awaiter(this, void 0, void 0, function () {\n    var decoder, contentType, delimiter, boundaryVal, boundary, buffer, iterator, running, _f, value, done, chunk, bi, message, i, headers, contentType_1, body, result, next;\n\n    var _g, _h;\n\n    return __generator(this, function (_j) {\n      switch (_j.label) {\n        case 0:\n          if (TextDecoder === undefined) {\n            throw new Error(\"TextDecoder must be defined in the environment: please import a polyfill.\");\n          }\n\n          decoder = new TextDecoder(\"utf-8\");\n          contentType = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.get(\"content-type\");\n          delimiter = \"boundary=\";\n          boundaryVal = (contentType === null || contentType === void 0 ? void 0 : contentType.includes(delimiter)) ? contentType === null || contentType === void 0 ? void 0 : contentType.substring((contentType === null || contentType === void 0 ? void 0 : contentType.indexOf(delimiter)) + delimiter.length).replace(/['\"]/g, \"\").replace(/\\;(.*)/gm, \"\").trim() : \"-\";\n          boundary = \"--\".concat(boundaryVal);\n          buffer = \"\";\n          iterator = responseIterator(response);\n          running = true;\n          _j.label = 1;\n\n        case 1:\n          if (!running) return [3, 3];\n          return [4, iterator.next()];\n\n        case 2:\n          _f = _j.sent(), value = _f.value, done = _f.done;\n          chunk = typeof value === \"string\" ? value : decoder.decode(value);\n          running = !done;\n          buffer += chunk;\n          bi = buffer.indexOf(boundary);\n\n          while (bi > -1) {\n            message = void 0;\n            _g = [buffer.slice(0, bi), buffer.slice(bi + boundary.length)], message = _g[0], buffer = _g[1];\n\n            if (message.trim()) {\n              i = message.indexOf(\"\\r\\n\\r\\n\");\n              headers = parseHeaders(message.slice(0, i));\n              contentType_1 = headers[\"content-type\"];\n\n              if (contentType_1 && contentType_1.toLowerCase().indexOf(\"application/json\") === -1) {\n                throw new Error(\"Unsupported patch content type: application/json is required.\");\n              }\n\n              body = message.slice(i);\n\n              try {\n                result = parseJsonBody(response, body.replace(\"\\r\\n\", \"\"));\n\n                if (Object.keys(result).length > 1 || \"data\" in result || \"incremental\" in result || \"errors\" in result || \"payload\" in result) {\n                  if (isApolloPayloadResult(result)) {\n                    next = {};\n\n                    if (\"payload\" in result) {\n                      next = __assign({}, result.payload);\n                    }\n\n                    if (\"errors\" in result) {\n                      next = __assign(__assign({}, next), {\n                        extensions: __assign(__assign({}, \"extensions\" in next ? next.extensions : null), (_h = {}, _h[PROTOCOL_ERRORS_SYMBOL] = result.errors, _h))\n                      });\n                    }\n\n                    (_b = observer.next) === null || _b === void 0 ? void 0 : _b.call(observer, next);\n                  } else {\n                    (_c = observer.next) === null || _c === void 0 ? void 0 : _c.call(observer, result);\n                  }\n                } else if (Object.keys(result).length === 1 && \"hasNext\" in result && !result.hasNext) {\n                  (_d = observer.complete) === null || _d === void 0 ? void 0 : _d.call(observer);\n                }\n              } catch (err) {\n                handleError(err, observer);\n              }\n            }\n\n            bi = buffer.indexOf(boundary);\n          }\n\n          return [3, 1];\n\n        case 3:\n          (_e = observer.complete) === null || _e === void 0 ? void 0 : _e.call(observer);\n          return [2];\n      }\n    });\n  });\n}\nexport function parseHeaders(headerText) {\n  var headersInit = {};\n  headerText.split(\"\\n\").forEach(function (line) {\n    var i = line.indexOf(\":\");\n\n    if (i > -1) {\n      var name_1 = line.slice(0, i).trim().toLowerCase();\n      var value = line.slice(i + 1).trim();\n      headersInit[name_1] = value;\n    }\n  });\n  return headersInit;\n}\nexport function parseJsonBody(response, bodyText) {\n  if (response.status >= 300) {\n    var getResult = function () {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n\n    throwServerError(response, getResult(), \"Response not successful: Received status code \".concat(response.status));\n  }\n\n  try {\n    return JSON.parse(bodyText);\n  } catch (err) {\n    var parseError = err;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\nexport function handleError(err, observer) {\n  var _a, _b;\n\n  if (err.name === \"AbortError\") return;\n\n  if (err.result && err.result.errors && err.result.data) {\n    (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, err.result);\n  }\n\n  (_b = observer.error) === null || _b === void 0 ? void 0 : _b.call(observer, err);\n}\nexport function readJsonBody(response, operation, observer) {\n  parseAndCheckHttpResponse(operation)(response).then(function (result) {\n    var _a, _b;\n\n    (_a = observer.next) === null || _a === void 0 ? void 0 : _a.call(observer, result);\n    (_b = observer.complete) === null || _b === void 0 ? void 0 : _b.call(observer);\n  }).catch(function (err) {\n    return handleError(err, observer);\n  });\n}\nexport function parseAndCheckHttpResponse(operations) {\n  return function (response) {\n    return response.text().then(function (bodyText) {\n      return parseJsonBody(response, bodyText);\n    }).then(function (result) {\n      if (response.status >= 300) {\n        throwServerError(response, result, \"Response not successful: Received status code \".concat(response.status));\n      }\n\n      if (!Array.isArray(result) && !hasOwnProperty.call(result, \"data\") && !hasOwnProperty.call(result, \"errors\")) {\n        throwServerError(response, result, \"Server response was missing for query '\".concat(Array.isArray(operations) ? operations.map(function (op) {\n          return op.operationName;\n        }) : operations.operationName, \"'.\"));\n      }\n\n      return result;\n    });\n  };\n}","map":{"version":3,"sources":["../../../src/link/http/parseAndCheckHttpResponse.ts"],"names":[],"mappings":"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","sourcesContent":["import { responseIterator } from \"./responseIterator\";\nimport { Operation } from \"../core\";\nimport { throwServerError } from \"../utils\";\nimport { PROTOCOL_ERRORS_SYMBOL } from '../../errors';\nimport { Observer } from \"../../utilities\";\nimport {\n  isApolloPayloadResult\n} from '../../utilities/common/incrementalResult';\n\nconst { hasOwnProperty } = Object.prototype;\n\nexport type ServerParseError = Error & {\n  response: Response;\n  statusCode: number;\n  bodyText: string;\n};\n\nexport async function readMultipartBody<\n  T extends object = Record<string, unknown>\n>(response: Response, observer: Observer<T>) {\n  if (TextDecoder === undefined) {\n    throw new Error(\n      \"TextDecoder must be defined in the environment: please import a polyfill.\"\n    );\n  }\n  const decoder = new TextDecoder(\"utf-8\");\n  const contentType = response.headers?.get(\"content-type\");\n  const delimiter = \"boundary=\";\n\n  // parse boundary value and ignore any subsequent name/value pairs after ;\n  // https://www.rfc-editor.org/rfc/rfc9110.html#name-parameters\n  // e.g. multipart/mixed;boundary=\"graphql\";deferSpec=20220824\n  // if no boundary is specified, default to -\n  const boundaryVal = contentType?.includes(delimiter)\n    ? contentType\n        ?.substring(contentType?.indexOf(delimiter) + delimiter.length)\n        .replace(/['\"]/g, \"\")\n        .replace(/\\;(.*)/gm, \"\")\n        .trim()\n    : \"-\";\n\n  let boundary = `--${boundaryVal}`;\n  let buffer = \"\";\n  const iterator = responseIterator(response);\n  let running = true;\n\n  while (running) {\n    const { value, done } = await iterator.next();\n    const chunk = typeof value === \"string\" ? value : decoder.decode(value);\n    running = !done;\n    buffer += chunk;\n    let bi = buffer.indexOf(boundary);\n\n    while (bi > -1) {\n      let message: string;\n      [message, buffer] = [\n        buffer.slice(0, bi),\n        buffer.slice(bi + boundary.length),\n      ];\n      if (message.trim()) {\n        const i = message.indexOf(\"\\r\\n\\r\\n\");\n        const headers = parseHeaders(message.slice(0, i));\n        const contentType = headers[\"content-type\"];\n        if (\n          contentType &&\n          contentType.toLowerCase().indexOf(\"application/json\") === -1\n        ) {\n          throw new Error(\n            \"Unsupported patch content type: application/json is required.\"\n          );\n        }\n        const body = message.slice(i);\n\n        try {\n          const result = parseJsonBody<T>(response, body.replace(\"\\r\\n\", \"\"));\n          if (\n            Object.keys(result).length > 1 ||\n            \"data\" in result ||\n            \"incremental\" in result ||\n            \"errors\" in result ||\n            \"payload\" in result\n          ) {\n            if (isApolloPayloadResult(result)) {\n              let next = {};\n              if (\"payload\" in result) {\n                next = { ...result.payload };\n              }\n              if (\"errors\" in result) {\n                next = {\n                  ...next,\n                  extensions: {\n                    ...(\"extensions\" in next ? next.extensions : null as any),\n                    [PROTOCOL_ERRORS_SYMBOL]: result.errors\n                  },\n                };\n              }\n              observer.next?.(next as T);\n            } else {\n              // for the last chunk with only `hasNext: false`\n              // we don't need to call observer.next as there is no data/errors\n              observer.next?.(result);\n            }\n          } else if (\n            // If the chunk contains only a \"hasNext: false\", we can call\n            // observer.complete() immediately.\n            Object.keys(result).length === 1 &&\n            \"hasNext\" in result &&\n            !result.hasNext\n          ) {\n            observer.complete?.();\n          }\n        } catch (err) {\n          handleError(err, observer);\n        }\n      }\n      bi = buffer.indexOf(boundary);\n    }\n  }\n  observer.complete?.();\n}\n\nexport function parseHeaders(headerText: string): Record<string, string> {\n  const headersInit: Record<string, string> = {};\n  headerText.split(\"\\n\").forEach((line) => {\n    const i = line.indexOf(\":\");\n    if (i > -1) {\n      // normalize headers to lowercase\n      const name = line.slice(0, i).trim().toLowerCase();\n      const value = line.slice(i + 1).trim();\n      headersInit[name] = value;\n    }\n  });\n  return headersInit;\n}\n\nexport function parseJsonBody<T>(response: Response, bodyText: string): T {\n  if (response.status >= 300) {\n    // Network error\n    const getResult = () => {\n      try {\n        return JSON.parse(bodyText);\n      } catch (err) {\n        return bodyText;\n      }\n    };\n    throwServerError(\n      response,\n      getResult(),\n      `Response not successful: Received status code ${response.status}`\n    );\n  }\n\n  try {\n    return JSON.parse(bodyText) as T;\n  } catch (err) {\n    const parseError = err as ServerParseError;\n    parseError.name = \"ServerParseError\";\n    parseError.response = response;\n    parseError.statusCode = response.status;\n    parseError.bodyText = bodyText;\n    throw parseError;\n  }\n}\n\nexport function handleError(err: any, observer: Observer<any>) {\n  if (err.name === \"AbortError\") return;\n  // if it is a network error, BUT there is graphql result info fire\n  // the next observer before calling error this gives apollo-client\n  // (and react-apollo) the `graphqlErrors` and `networkErrors` to\n  // pass to UI this should only happen if we *also* have data as\n  // part of the response key per the spec\n  if (err.result && err.result.errors && err.result.data) {\n    // if we don't call next, the UI can only show networkError\n    // because AC didn't get any graphqlErrors this is graphql\n    // execution result info (i.e errors and possibly data) this is\n    // because there is no formal spec how errors should translate to\n    // http status codes. So an auth error (401) could have both data\n    // from a public field, errors from a private field, and a status\n    // of 401\n    // {\n    //  user { // this will have errors\n    //    firstName\n    //  }\n    //  products { // this is public so will have data\n    //    cost\n    //  }\n    // }\n    //\n    // the result of above *could* look like this:\n    // {\n    //   data: { products: [{ cost: \"$10\" }] },\n    //   errors: [{\n    //      message: 'your session has timed out',\n    //      path: []\n    //   }]\n    // }\n    // status code of above would be a 401\n    // in the UI you want to show data where you can, errors as data where you can\n    // and use correct http status codes\n    observer.next?.(err.result);\n  }\n\n  observer.error?.(err);\n}\n\nexport function readJsonBody<T = Record<string, unknown>>(\n  response: Response,\n  operation: Operation,\n  observer: Observer<T>\n) {\n  parseAndCheckHttpResponse(operation)(response)\n    .then((result) => {\n      observer.next?.(result);\n      observer.complete?.();\n    })\n    .catch((err) => handleError(err, observer));\n}\n\nexport function parseAndCheckHttpResponse(operations: Operation | Operation[]) {\n  return (response: Response) =>\n    response\n      .text()\n      .then((bodyText) => parseJsonBody(response, bodyText))\n      .then((result: any) => {\n        if (response.status >= 300) {\n          // Network error\n          throwServerError(\n            response,\n            result,\n            `Response not successful: Received status code ${response.status}`\n          );\n        }\n        if (\n          !Array.isArray(result) &&\n          !hasOwnProperty.call(result, \"data\") &&\n          !hasOwnProperty.call(result, \"errors\")\n        ) {\n          // Data error\n          throwServerError(\n            response,\n            result,\n            `Server response was missing for query '${\n              Array.isArray(operations)\n                ? operations.map((op) => op.operationName)\n                : operations.operationName\n            }'.`\n          );\n        }\n        return result;\n      });\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}