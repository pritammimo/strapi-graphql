{"ast":null,"code":"import { isReference, isField, DeepMerger, resultKeyNameFromField, shouldInclude, isNonNullObject, compact, createFragmentMap, getFragmentDefinitions, isArray } from \"../../utilities/index.js\";\nexport var hasOwn = Object.prototype.hasOwnProperty;\nexport function isNullish(value) {\n  return value === null || value === void 0;\n}\nexport { isArray };\nexport function defaultDataIdFromObject(_a, context) {\n  var __typename = _a.__typename,\n      id = _a.id,\n      _id = _a._id;\n\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject = !isNullish(id) ? {\n        id: id\n      } : !isNullish(_id) ? {\n        _id: _id\n      } : void 0;\n    }\n\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return \"\".concat(__typename, \":\").concat(typeof id === \"number\" || typeof id === \"string\" ? id : JSON.stringify(id));\n    }\n  }\n}\nvar defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  canonizeResults: false\n};\nexport function normalizeConfig(config) {\n  return compact(defaultConfig, config);\n}\nexport function shouldCanonizeResults(config) {\n  var value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\nexport function getTypenameFromStoreObject(store, objectOrReference) {\n  return isReference(objectOrReference) ? store.get(objectOrReference.__ref, \"__typename\") : objectOrReference && objectOrReference.__typename;\n}\nexport var TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\nexport function fieldNameFromStoreName(storeFieldName) {\n  var match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\nexport function selectionSetMatchesResult(selectionSet, result, variables) {\n  if (isNonNullObject(result)) {\n    return isArray(result) ? result.every(function (item) {\n      return selectionSetMatchesResult(selectionSet, item, variables);\n    }) : selectionSet.selections.every(function (field) {\n      if (isField(field) && shouldInclude(field, variables)) {\n        var key = resultKeyNameFromField(field);\n        return hasOwn.call(result, key) && (!field.selectionSet || selectionSetMatchesResult(field.selectionSet, result[key], variables));\n      }\n\n      return true;\n    });\n  }\n\n  return false;\n}\nexport function storeValueIsStoreObject(value) {\n  return isNonNullObject(value) && !isReference(value) && !isArray(value);\n}\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger();\n}\nexport function extractFragmentContext(document, fragments) {\n  var fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap: fragmentMap,\n    lookupFragment: function (name) {\n      var def = fragmentMap[name];\n\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n\n      return def || null;\n    }\n  };\n}","map":{"version":3,"sources":["../../../src/cache/inmemory/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import { DocumentNode, FragmentDefinitionNode, SelectionSetNode } from 'graphql';\n\nimport {\n  NormalizedCache,\n  InMemoryCacheConfig,\n} from './types';\n\nimport { KeyFieldsContext } from './policies';\nimport { FragmentRegistryAPI } from './fragmentRegistry';\n\nimport {\n  Reference,\n  isReference,\n  StoreValue,\n  StoreObject,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  FragmentMap,\n  FragmentMapFunction,\n  createFragmentMap,\n  getFragmentDefinitions,\n  isArray,\n} from '../../utilities';\n\nexport const {\n  hasOwnProperty: hasOwn,\n} = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport { isArray };\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext,\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        !isNullish(id) ? { id } :\n        !isNullish(_id) ? { _id } :\n        void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${(\n        typeof id === \"number\" ||\n        typeof id === \"string\"\n      ) ? id : JSON.stringify(id)}`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">,\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference,\n): string | undefined {\n  return isReference(objectOrReference)\n    ? store.get(objectOrReference.__ref, \"__typename\") as string\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>,\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result)\n      ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables))\n      : selectionSet.selections.every(field => {\n        if (isField(field) && shouldInclude(field, variables)) {\n          const key = resultKeyNameFromField(field);\n          return hasOwn.call(result, key) &&\n            (!field.selectionSet ||\n             selectionSetMatchesResult(field.selectionSet, result[key], variables));\n        }\n        // If the selection has been skipped with @skip(true) or\n        // @include(false), it should not count against the matching. If\n        // the selection is not a field, it must be a fragment (inline or\n        // named). We will determine if selectionSetMatchesResult for that\n        // fragment when we get to it, so for now we return true.\n        return true;\n      });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue,\n): value is StoreObject {\n  return isNonNullObject(value) &&\n    !isReference(value) &&\n    !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger;\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI,\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}