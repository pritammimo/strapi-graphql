{"ast":null,"code":"import { isNonNullObject } from \"./objects.js\";\nimport { isNonEmptyArray } from \"./arrays.js\";\nimport { DeepMerger } from \"./mergeDeep.js\";\nexport function isExecutionPatchIncrementalResult(value) {\n  return \"incremental\" in value;\n}\nexport function isExecutionPatchInitialResult(value) {\n  return \"hasNext\" in value && \"data\" in value;\n}\nexport function isExecutionPatchResult(value) {\n  return isExecutionPatchIncrementalResult(value) || isExecutionPatchInitialResult(value);\n}\nexport function isApolloPayloadResult(value) {\n  return isNonNullObject(value) && \"payload\" in value;\n}\nexport function mergeIncrementalData(prevResult, result) {\n  var mergedData = prevResult;\n  var merger = new DeepMerger();\n\n  if (isExecutionPatchIncrementalResult(result) && isNonEmptyArray(result.incremental)) {\n    result.incremental.forEach(function (_a) {\n      var data = _a.data,\n          path = _a.path;\n\n      for (var i = path.length - 1; i >= 0; --i) {\n        var key = path[i];\n        var isNumericKey = !isNaN(+key);\n        var parent_1 = isNumericKey ? [] : {};\n        parent_1[key] = data;\n        data = parent_1;\n      }\n\n      mergedData = merger.merge(mergedData, data);\n    });\n  }\n\n  return mergedData;\n}","map":{"version":3,"sources":["../../../src/utilities/common/incrementalResult.ts"],"names":[],"mappings":"AAOA,SAAS,eAAT,QAAgC,cAAhC;AACA,SAAS,eAAT,QAAgC,aAAhC;AACA,SAAS,UAAT,QAA2B,gBAA3B;AAEA,OAAM,SAAU,iCAAV,CACJ,KADI,EACiB;AAErB,SAAO,iBAAiB,KAAxB;AACD;AAED,OAAM,SAAU,6BAAV,CACJ,KADI,EACiB;AAErB,SAAO,aAAa,KAAb,IAAsB,UAAU,KAAvC;AACD;AAED,OAAM,SAAU,sBAAV,CACJ,KADI,EACiB;AAErB,SACE,iCAAiC,CAAC,KAAD,CAAjC,IACA,6BAA6B,CAAC,KAAD,CAF/B;AAID;AAKD,OAAM,SAAU,qBAAV,CACJ,KADI,EACU;AAEd,SAAO,eAAe,CAAC,KAAD,CAAf,IAA0B,aAAa,KAA9C;AACD;AAED,OAAM,SAAU,oBAAV,CACJ,UADI,EAEJ,MAFI,EAE+B;AAEnC,MAAI,UAAU,GAAG,UAAjB;AACA,MAAM,MAAM,GAAG,IAAI,UAAJ,EAAf;;AACA,MACE,iCAAiC,CAAC,MAAD,CAAjC,IACA,eAAe,CAAC,MAAM,CAAC,WAAR,CAFjB,EAGE;AACA,IAAA,MAAM,CAAC,WAAP,CAAmB,OAAnB,CAA2B,UAAC,EAAD,EAAe;UAAZ,IAAI,GAAA,EAAA,CAAA,I;UAAE,IAAI,GAAA,EAAA,CAAA,I;;AACtC,WAAK,IAAI,CAAC,GAAG,IAAI,CAAC,MAAL,GAAc,CAA3B,EAA8B,CAAC,IAAI,CAAnC,EAAsC,EAAE,CAAxC,EAA2C;AACzC,YAAM,GAAG,GAAG,IAAI,CAAC,CAAD,CAAhB;AACA,YAAM,YAAY,GAAG,CAAC,KAAK,CAAC,CAAC,GAAF,CAA3B;AACA,YAAM,QAAM,GAAiC,YAAY,GAAG,EAAH,GAAQ,EAAjE;AACA,QAAA,QAAM,CAAC,GAAD,CAAN,GAAc,IAAd;AACA,QAAA,IAAI,GAAG,QAAP;AACD;;AACD,MAAA,UAAU,GAAG,MAAM,CAAC,KAAP,CAAa,UAAb,EAAyB,IAAzB,CAAb;AACD,KATD;AAUD;;AACD,SAAO,UAAP;AACD","sourcesContent":["import {\n  ExecutionPatchIncrementalResult,\n  ExecutionPatchInitialResult,\n  ExecutionPatchResult,\n  ApolloPayloadResult,\n  FetchResult,\n} from \"../../link/core\";\nimport { isNonNullObject } from \"./objects\";\nimport { isNonEmptyArray } from \"./arrays\";\nimport { DeepMerger } from \"./mergeDeep\";\n\nexport function isExecutionPatchIncrementalResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchIncrementalResult {\n  return \"incremental\" in value;\n}\n\nexport function isExecutionPatchInitialResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchInitialResult<T> {\n  return \"hasNext\" in value && \"data\" in value;\n}\n\nexport function isExecutionPatchResult<T>(\n  value: FetchResult<T>\n): value is ExecutionPatchResult<T> {\n  return (\n    isExecutionPatchIncrementalResult(value) ||\n    isExecutionPatchInitialResult(value)\n  );\n}\n\n// This function detects an Apollo payload result before it is transformed\n// into a FetchResult via HttpLink; it cannot detect an ApolloPayloadResult\n// once it leaves the link chain.\nexport function isApolloPayloadResult(\n  value: unknown\n): value is ApolloPayloadResult {\n  return isNonNullObject(value) && \"payload\" in value;\n}\n\nexport function mergeIncrementalData<TData extends object>(\n  prevResult: TData,\n  result: ExecutionPatchResult<TData>\n) {\n  let mergedData = prevResult;\n  const merger = new DeepMerger();\n  if (\n    isExecutionPatchIncrementalResult(result) &&\n    isNonEmptyArray(result.incremental)\n  ) {\n    result.incremental.forEach(({ data, path }) => {\n      for (let i = path.length - 1; i >= 0; --i) {\n        const key = path[i];\n        const isNumericKey = !isNaN(+key);\n        const parent: Record<string | number, any> = isNumericKey ? [] : {};\n        parent[key] = data;\n        data = parent as typeof data;\n      }\n      mergedData = merger.merge(mergedData, data);\n    });\n  }\n  return mergedData as TData;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}