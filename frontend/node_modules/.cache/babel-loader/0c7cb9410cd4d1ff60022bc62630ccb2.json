{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { useCallback, useMemo, useRef } from 'react';\nimport { mergeOptions } from \"../../utilities/index.js\";\nimport { useInternalState } from \"./useQuery.js\";\nimport { useApolloClient } from \"./useApolloClient.js\";\nvar EAGER_METHODS = ['refetch', 'reobserve', 'fetchMore', 'updateQuery', 'startPolling', 'subscribeToMore'];\nexport function useLazyQuery(query, options) {\n  var _a;\n\n  var execOptionsRef = useRef();\n  var optionsRef = useRef();\n  var queryRef = useRef();\n  var merged = execOptionsRef.current ? mergeOptions(options, execOptionsRef.current) : options;\n  var document = (_a = merged === null || merged === void 0 ? void 0 : merged.query) !== null && _a !== void 0 ? _a : query;\n  optionsRef.current = merged;\n  queryRef.current = document;\n  var internalState = useInternalState(useApolloClient(options && options.client), document);\n  var useQueryResult = internalState.useQuery(__assign(__assign({}, merged), {\n    skip: !execOptionsRef.current\n  }));\n  var initialFetchPolicy = useQueryResult.observable.options.initialFetchPolicy || internalState.getDefaultFetchPolicy();\n  var result = Object.assign(useQueryResult, {\n    called: !!execOptionsRef.current\n  });\n  var eagerMethods = useMemo(function () {\n    var eagerMethods = {};\n\n    var _loop_1 = function (key) {\n      var method = result[key];\n\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          internalState.forceUpdate();\n        }\n\n        return method.apply(this, arguments);\n      };\n    };\n\n    for (var _i = 0, EAGER_METHODS_1 = EAGER_METHODS; _i < EAGER_METHODS_1.length; _i++) {\n      var key = EAGER_METHODS_1[_i];\n\n      _loop_1(key);\n    }\n\n    return eagerMethods;\n  }, []);\n  Object.assign(result, eagerMethods);\n  var execute = useCallback(function (executeOptions) {\n    execOptionsRef.current = executeOptions ? __assign(__assign({}, executeOptions), {\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy\n    }) : {\n      fetchPolicy: initialFetchPolicy\n    };\n    var options = mergeOptions(optionsRef.current, __assign({\n      query: queryRef.current\n    }, execOptionsRef.current));\n    var promise = internalState.executeQuery(__assign(__assign({}, options), {\n      skip: false\n    })).then(function (queryResult) {\n      return Object.assign(queryResult, eagerMethods);\n    });\n    promise.catch(function () {});\n    return promise;\n  }, []);\n  return [execute, result];\n}","map":{"version":3,"sources":["../../../src/react/hooks/useLazyQuery.ts"],"names":[],"mappings":"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","sourcesContent":["import { DocumentNode } from 'graphql';\nimport { TypedDocumentNode } from '@graphql-typed-document-node/core';\nimport { useCallback, useMemo, useRef } from 'react';\n\nimport { OperationVariables } from '../../core';\nimport { mergeOptions } from '../../utilities';\nimport {\n  LazyQueryHookOptions,\n  LazyQueryResultTuple,\n  QueryResult,\n} from '../types/types';\nimport { useInternalState } from './useQuery';\nimport { useApolloClient } from './useApolloClient';\n\n// The following methods, when called will execute the query, regardless of\n// whether the useLazyQuery execute function was called before.\nconst EAGER_METHODS = [\n  'refetch',\n  'reobserve',\n  'fetchMore',\n  'updateQuery',\n  'startPolling',\n  'subscribeToMore',\n] as const;\n\nexport function useLazyQuery<TData = any, TVariables extends OperationVariables = OperationVariables>(\n  query: DocumentNode | TypedDocumentNode<TData, TVariables>,\n  options?: LazyQueryHookOptions<TData, TVariables>\n): LazyQueryResultTuple<TData, TVariables> {\n  const execOptionsRef = useRef<Partial<LazyQueryHookOptions<TData, TVariables>>>();\n  const optionsRef = useRef<LazyQueryHookOptions<TData, TVariables>>();\n  const queryRef = useRef<DocumentNode | TypedDocumentNode<TData, TVariables>>();\n  const merged = execOptionsRef.current ? mergeOptions(options, execOptionsRef.current) : options;\n  const document = merged?.query ?? query;\n\n  // Use refs to track options and the used query to ensure the `execute` \n  // function remains referentially stable between renders.\n  optionsRef.current = merged;\n  queryRef.current = document;\n\n  const internalState = useInternalState<TData, TVariables>(\n    useApolloClient(options && options.client),\n    document\n  );\n\n  const useQueryResult = internalState.useQuery({\n    ...merged,\n    skip: !execOptionsRef.current,\n  });\n\n  const initialFetchPolicy =\n    useQueryResult.observable.options.initialFetchPolicy ||\n    internalState.getDefaultFetchPolicy();\n\n  const result: QueryResult<TData, TVariables> =\n    Object.assign(useQueryResult, {\n      called: !!execOptionsRef.current,\n    });\n\n  // We use useMemo here to make sure the eager methods have a stable identity.\n  const eagerMethods = useMemo(() => {\n    const eagerMethods: Record<string, any> = {};\n    for (const key of EAGER_METHODS) {\n      const method = result[key];\n      eagerMethods[key] = function () {\n        if (!execOptionsRef.current) {\n          execOptionsRef.current = Object.create(null);\n          // Only the first time populating execOptionsRef.current matters here.\n          internalState.forceUpdate();\n        }\n        return method.apply(this, arguments);\n      };\n    }\n\n    return eagerMethods;\n  }, []);\n\n  Object.assign(result, eagerMethods);\n\n  const execute = useCallback<\n    LazyQueryResultTuple<TData, TVariables>[0]\n  >(executeOptions => {\n    execOptionsRef.current = executeOptions ? {\n      ...executeOptions,\n      fetchPolicy: executeOptions.fetchPolicy || initialFetchPolicy,\n    } : {\n      fetchPolicy: initialFetchPolicy,\n    };\n\n    const options = mergeOptions(optionsRef.current, {\n      query: queryRef.current,\n      ...execOptionsRef.current,\n    })\n\n    const promise = internalState\n      .executeQuery({ ...options, skip: false }) \n      .then((queryResult) => Object.assign(queryResult, eagerMethods));\n\n    // Because the return value of `useLazyQuery` is usually floated, we need\n    // to catch the promise to prevent unhandled rejections.\n    promise.catch(() => {});\n\n    return promise;\n  }, []);\n\n  return [execute, result];\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}