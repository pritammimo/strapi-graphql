{"ast":null,"code":"import { Slot } from \"./slot.js\";\nexport { Slot };\nexport const {\n  bind,\n  noContext\n} = Slot; // Like global.setTimeout, except the callback runs with captured context.\n\nexport { setTimeoutWithContext as setTimeout };\n\nfunction setTimeoutWithContext(callback, delay) {\n  return setTimeout(bind(callback), delay);\n} // Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\n\n\nexport function asyncFromGen(genFn) {\n  return function () {\n    const gen = genFn.apply(this, arguments);\n    const boundNext = bind(gen.next);\n    const boundThrow = bind(gen.throw);\n    return new Promise((resolve, reject) => {\n      function invoke(method, argument) {\n        try {\n          var result = method.call(gen, argument);\n        } catch (error) {\n          return reject(error);\n        }\n\n        const next = result.done ? resolve : invokeNext;\n\n        if (isPromiseLike(result.value)) {\n          result.value.then(next, result.done ? reject : invokeThrow);\n        } else {\n          next(result.value);\n        }\n      }\n\n      const invokeNext = value => invoke(boundNext, value);\n\n      const invokeThrow = error => invoke(boundThrow, error);\n\n      invokeNext();\n    });\n  };\n}\n\nfunction isPromiseLike(value) {\n  return value && typeof value.then === \"function\";\n} // If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\n\n\nconst wrappedFibers = [];\nexport function wrapYieldingFiberMethods(Fiber) {\n  // There can be only one implementation of Fiber per process, so this array\n  // should never grow longer than one element.\n  if (wrappedFibers.indexOf(Fiber) < 0) {\n    const wrap = (obj, method) => {\n      const fn = obj[method];\n\n      obj[method] = function () {\n        return noContext(fn, arguments, this);\n      };\n    }; // These methods can yield, according to\n    // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n\n\n    wrap(Fiber, \"yield\");\n    wrap(Fiber.prototype, \"run\");\n    wrap(Fiber.prototype, \"throwInto\");\n    wrappedFibers.push(Fiber);\n  }\n\n  return Fiber;\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,QAAqB,WAArB;AACA,SAAS,IAAT;AACA,OAAO,MAAM;AAAE,EAAA,IAAF;AAAQ,EAAA;AAAR,IAAsB,IAA5B,C,CAUP;;AACA,SAAS,qBAAqB,IAAI,UAAlC;;AACA,SAAS,qBAAT,CAA+B,QAA/B,EAAoD,KAApD,EAAiE;AAC/D,SAAO,UAAU,CAAC,IAAI,CAAC,QAAD,CAAL,EAAiB,KAAjB,CAAjB;AACD,C,CAED;AACA;;;AACA,OAAM,SAAU,YAAV,CAMJ,KANI,EAMwD;AAE5D,SAAO,YAAA;AACL,UAAM,GAAG,GAAG,KAAK,CAAC,KAAN,CAAY,IAAZ,EAAkB,SAAlB,CAAZ;AAOA,UAAM,SAAS,GAAW,IAAI,CAAC,GAAG,CAAC,IAAL,CAA9B;AACA,UAAM,UAAU,GAAW,IAAI,CAAC,GAAG,CAAC,KAAL,CAA/B;AAEA,WAAO,IAAI,OAAJ,CAAY,CAAC,OAAD,EAAU,MAAV,KAAoB;AACrC,eAAS,MAAT,CAAgB,MAAhB,EAAgC,QAAhC,EAA6C;AAC3C,YAAI;AACF,cAAI,MAAM,GAAQ,MAAM,CAAC,IAAP,CAAY,GAAZ,EAAiB,QAAjB,CAAlB;AACD,SAFD,CAEE,OAAO,KAAP,EAAc;AACd,iBAAO,MAAM,CAAC,KAAD,CAAb;AACD;;AACD,cAAM,IAAI,GAAG,MAAM,CAAC,IAAP,GAAc,OAAd,GAAwB,UAArC;;AACA,YAAI,aAAa,CAAC,MAAM,CAAC,KAAR,CAAjB,EAAiC;AAC/B,UAAA,MAAM,CAAC,KAAP,CAAa,IAAb,CAAkB,IAAlB,EAAwB,MAAM,CAAC,IAAP,GAAc,MAAd,GAAuB,WAA/C;AACD,SAFD,MAEO;AACL,UAAA,IAAI,CAAC,MAAM,CAAC,KAAR,CAAJ;AACD;AACF;;AACD,YAAM,UAAU,GAAI,KAAD,IAAiB,MAAM,CAAC,SAAD,EAAY,KAAZ,CAA1C;;AACA,YAAM,WAAW,GAAI,KAAD,IAAgB,MAAM,CAAC,UAAD,EAAa,KAAb,CAA1C;;AACA,MAAA,UAAU;AACX,KAjBM,CAAP;AAkBmC,GA7BrC;AA8BD;;AAED,SAAS,aAAT,CAAuB,KAAvB,EAAiC;AAC/B,SAAO,KAAK,IAAI,OAAO,KAAK,CAAC,IAAb,KAAsB,UAAtC;AACD,C,CAED;AACA;AACA;;;AACA,MAAM,aAAa,GAAe,EAAlC;AACA,OAAM,SAAU,wBAAV,CAAuD,KAAvD,EAA+D;AACnE;AACA;AACA,MAAI,aAAa,CAAC,OAAd,CAAsB,KAAtB,IAA+B,CAAnC,EAAsC;AACpC,UAAM,IAAI,GAAG,CAAC,GAAD,EAAW,MAAX,KAA6B;AACxC,YAAM,EAAE,GAAG,GAAG,CAAC,MAAD,CAAd;;AACA,MAAA,GAAG,CAAC,MAAD,CAAH,GAAc,YAAA;AACZ,eAAO,SAAS,CAAC,EAAD,EAAK,SAAL,EAAuB,IAAvB,CAAhB;AACD,OAFD;AAGD,KALD,CADoC,CAOpC;AACA;;;AACA,IAAA,IAAI,CAAC,KAAD,EAAQ,OAAR,CAAJ;AACA,IAAA,IAAI,CAAC,KAAK,CAAC,SAAP,EAAkB,KAAlB,CAAJ;AACA,IAAA,IAAI,CAAC,KAAK,CAAC,SAAP,EAAkB,WAAlB,CAAJ;AACA,IAAA,aAAa,CAAC,IAAd,CAAmB,KAAnB;AACD;;AACD,SAAO,KAAP;AACD","sourceRoot":"","sourcesContent":["import { Slot } from \"./slot.js\";\nexport { Slot };\nexport const { bind, noContext } = Slot;\n// Like global.setTimeout, except the callback runs with captured context.\nexport { setTimeoutWithContext as setTimeout };\nfunction setTimeoutWithContext(callback, delay) {\n    return setTimeout(bind(callback), delay);\n}\n// Turn any generator function into an async function (using yield instead\n// of await), with context automatically preserved across yields.\nexport function asyncFromGen(genFn) {\n    return function () {\n        const gen = genFn.apply(this, arguments);\n        const boundNext = bind(gen.next);\n        const boundThrow = bind(gen.throw);\n        return new Promise((resolve, reject) => {\n            function invoke(method, argument) {\n                try {\n                    var result = method.call(gen, argument);\n                }\n                catch (error) {\n                    return reject(error);\n                }\n                const next = result.done ? resolve : invokeNext;\n                if (isPromiseLike(result.value)) {\n                    result.value.then(next, result.done ? reject : invokeThrow);\n                }\n                else {\n                    next(result.value);\n                }\n            }\n            const invokeNext = (value) => invoke(boundNext, value);\n            const invokeThrow = (error) => invoke(boundThrow, error);\n            invokeNext();\n        });\n    };\n}\nfunction isPromiseLike(value) {\n    return value && typeof value.then === \"function\";\n}\n// If you use the fibers npm package to implement coroutines in Node.js,\n// you should call this function at least once to ensure context management\n// remains coherent across any yields.\nconst wrappedFibers = [];\nexport function wrapYieldingFiberMethods(Fiber) {\n    // There can be only one implementation of Fiber per process, so this array\n    // should never grow longer than one element.\n    if (wrappedFibers.indexOf(Fiber) < 0) {\n        const wrap = (obj, method) => {\n            const fn = obj[method];\n            obj[method] = function () {\n                return noContext(fn, arguments, this);\n            };\n        };\n        // These methods can yield, according to\n        // https://github.com/laverdet/node-fibers/blob/ddebed9b8ae3883e57f822e2108e6943e5c8d2a8/fibers.js#L97-L100\n        wrap(Fiber, \"yield\");\n        wrap(Fiber.prototype, \"run\");\n        wrap(Fiber.prototype, \"throwInto\");\n        wrappedFibers.push(Fiber);\n    }\n    return Fiber;\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}